# blueprint: iso duration string support

implementation plan to deliver the wish

---

## overview

add support for iso 8601 duration strings (`PT5S`, `P1Y6M`, etc.) alongside the current object format (`{ seconds: 5 }`), with isomorphic operations that accept both.

## phases

### phase 0: domain objects

define the core types that enable the feature.

#### 0.1 create IsoDurationWords type

**file**: `src/domain.objects/IsoDurationWords.ts`

```ts
/**
 * .what = iso 8601 duration string format
 * .why = enables concise duration literals with compile-time validation
 * .note = no brand needed; template literal union is specific enough
 */

// time-only patterns
type IsoDurationWordsOnlyTime =
  | `PT${number}S`
  | `PT${number}M`
  | `PT${number}H`
  | `PT${number}M${number}S`
  | `PT${number}H${number}S`
  | `PT${number}H${number}M`
  | `PT${number}H${number}M${number}S`
  | `PT${number}.${number}S`
  | `PT${number}H${number}.${number}S`
  | `PT${number}M${number}.${number}S`
  | `PT${number}H${number}M${number}.${number}S`;

// date-only patterns
type IsoDurationWordsOnlyDate =
  | `P${number}Y`
  | `P${number}M`
  | `P${number}W`
  | `P${number}D`
  | `P${number}Y${number}M`
  | `P${number}Y${number}D`
  | `P${number}M${number}D`
  | `P${number}Y${number}M${number}D`
  | `P${number}W${number}D`;

// combined patterns (date + time)
type IsoDurationWordsCombined =
  | `P${number}DT${number}H`
  | `P${number}DT${number}M`
  | `P${number}DT${number}S`
  | `P${number}DT${number}H${number}M`
  | `P${number}DT${number}H${number}S`
  | `P${number}DT${number}M${number}S`
  | `P${number}DT${number}H${number}M${number}S`
  // ... additional patterns as needed
  | `P${number}Y${number}M${number}DT${number}H${number}M${number}S`
  | `P${number}Y${number}M${number}DT${number}H${number}M${number}.${number}S`;

export type IsoDurationWords =
  | IsoDurationWordsOnlyTime
  | IsoDurationWordsOnlyDate
  | IsoDurationWordsCombined;
```

**tests**: `src/domain.objects/IsoDurationWords.test.ts`

```ts
import { IsoDurationWords } from './IsoDurationWords';

describe('IsoDurationWords', () => {
  it('should accept valid time-only patterns', () => {
    const a: IsoDurationWords = 'PT5S';
    const b: IsoDurationWords = 'PT30M';
    const c: IsoDurationWords = 'PT2H';
    const d: IsoDurationWords = 'PT2H30M45S';
    const e: IsoDurationWords = 'PT0.5S';
    const f: IsoDurationWords = 'PT1.001S';
    expect([a, b, c, d, e, f]).toBeDefined();
  });

  it('should accept valid date-only patterns', () => {
    const a: IsoDurationWords = 'P1Y';
    const b: IsoDurationWords = 'P6M';
    const c: IsoDurationWords = 'P2W';
    const d: IsoDurationWords = 'P30D';
    const e: IsoDurationWords = 'P1Y6M15D';
    expect([a, b, c, d, e]).toBeDefined();
  });

  it('should accept valid combined patterns', () => {
    const a: IsoDurationWords = 'P1DT2H';
    const b: IsoDurationWords = 'P1Y6M15DT12H30M45S';
    const c: IsoDurationWords = 'P1Y6M15DT12H30M45.5S';
    expect([a, b, c]).toBeDefined();
  });

  it('should reject invalid patterns at compile time', () => {
    // @ts-expect-error - absent P designator
    const a: IsoDurationWords = '5S';
    // @ts-expect-error - lowercase designators
    const b: IsoDurationWords = 'pt5s';
    // @ts-expect-error - empty period
    const c: IsoDurationWords = 'P';
    // @ts-expect-error - empty time component
    const d: IsoDurationWords = 'PT';
    // @ts-expect-error - arbitrary string
    const e: IsoDurationWords = 'hello';
    // @ts-expect-error - empty string
    const f: IsoDurationWords = '';
    expect([a, b, c, d, e, f]).toBeDefined();
  });
});
```

#### 0.2 rename current type to IsoDurationShape

**file**: `src/domain.objects/IsoDurationShape.ts`

```ts
import { AsOfGlossary } from 'domain-glossaries';
import { PickAny } from 'type-fns';

/**
 * .what = duration as structured object
 * .why = enables programmatic manipulation of duration components
 * .note = glossary name indicates this type fits both IsoDurationShape and IsoDuration
 */
export type IsoDurationShape = AsOfGlossary<
  PickAny<{
    years: number;
    months: number;
    weeks: number;
    days: number;
    hours: number;
    minutes: number;
    seconds: number;
    milliseconds: number;
  }>,
  'iso-time.IsoDurationShape | iso-time.IsoDuration',
  false
>;
```

**tests**: `src/domain.objects/IsoDurationShape.test.ts`

```ts
import { IsoDurationShape } from './IsoDurationShape';

describe('IsoDurationShape', () => {
  it('should accept valid duration objects', () => {
    const a: IsoDurationShape = { seconds: 5 };
    const b: IsoDurationShape = { hours: 1, minutes: 30 };
    const c: IsoDurationShape = { years: 1, months: 6, days: 15 };
    const d: IsoDurationShape = { milliseconds: 500 };
    const e: IsoDurationShape = { weeks: 2, days: 3 };
    expect([a, b, c, d, e]).toBeDefined();
  });

  it('should reject invalid shapes at compile time', () => {
    // @ts-expect-error - empty object
    const a: IsoDurationShape = {};
    // @ts-expect-error - invalid key
    const b: IsoDurationShape = { foo: 1 };
    // @ts-expect-error - string value
    const c: IsoDurationShape = { seconds: '5' };
    // @ts-expect-error - null
    const d: IsoDurationShape = null;
    // @ts-expect-error - string instead of object
    const e: IsoDurationShape = 'PT5S';
    expect([a, b, c, d, e]).toBeDefined();
  });
});
```

#### 0.3 create unified IsoDuration type

**file**: `src/domain.objects/IsoDuration.ts`

```ts
import { AsOfGlossary } from 'domain-glossaries';
import type { IsoDurationWords } from './IsoDurationWords';
import type { IsoDurationShape } from './IsoDurationShape';

/**
 * .what = duration in either string or object format
 * .why = enables users to choose most convenient format per context
 */
export type IsoDuration = AsOfGlossary<
  IsoDurationWords | IsoDurationShape,
  'iso-time.IsoDuration',
  false
>;

// re-export constituent types
export type { IsoDurationWords, IsoDurationShape };
```

**tests**: `src/domain.objects/IsoDuration.test.ts`

```ts
import { IsoDuration, IsoDurationWords, IsoDurationShape } from './IsoDuration';

describe('IsoDuration', () => {
  it('should accept valid string formats', () => {
    const a: IsoDuration = 'PT5S';
    const b: IsoDuration = 'P1Y6M';
    const c: IsoDuration = 'P1DT2H30M';
    const d: IsoDuration = 'PT0.5S';
    expect([a, b, c, d]).toBeDefined();
  });

  it('should accept valid object formats', () => {
    const a: IsoDuration = { seconds: 5 };
    const b: IsoDuration = { years: 1, months: 6 };
    const c: IsoDuration = { days: 1, hours: 2, minutes: 30 };
    const d: IsoDuration = { milliseconds: 500 };
    expect([a, b, c, d]).toBeDefined();
  });

  it('should reject invalid formats at compile time', () => {
    // @ts-expect-error - invalid string
    const a: IsoDuration = 'invalid';
    // @ts-expect-error - absent P designator
    const b: IsoDuration = '5S';
    // @ts-expect-error - empty object
    const c: IsoDuration = {};
    // @ts-expect-error - invalid key
    const d: IsoDuration = { foo: 1 };
    // @ts-expect-error - null
    const e: IsoDuration = null;
    // @ts-expect-error - number
    const f: IsoDuration = 5000;
    expect([a, b, c, d, e, f]).toBeDefined();
  });

  it('should allow assignment between formats via union', () => {
    // both formats assignable to IsoDuration
    const strFormat: IsoDuration = 'PT1H';
    const objFormat: IsoDuration = { hours: 1 };

    // constituent types narrow correctly
    const words: IsoDurationWords = 'PT1H';
    const shape: IsoDurationShape = { hours: 1 };

    // constituent types assignable to union
    const fromWords: IsoDuration = words;
    const fromShape: IsoDuration = shape;

    expect([strFormat, objFormat, fromWords, fromShape]).toBeDefined();
  });
});
```

---

### phase 1: type guards

implement runtime validation for duration formats.

#### 1.1 create isIsoDurationWords guard

**file**: `src/domain.operations/checks/isIsoDurationWords.ts`

```ts
import { withAssure } from 'type-fns';
import type { IsoDurationWords } from '@src/domain.objects/IsoDurationWords';

// regex pattern for iso 8601 duration
const ISO_DURATION_REGEX = /^P(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/;

/**
 * .what = validates string is iso 8601 duration format
 * .why = runtime validation for external input
 */
export const isIsoDurationWords = withAssure(
  (input: unknown): input is IsoDurationWords => {
    if (typeof input !== 'string') return false;
    if (!input.startsWith('P')) return false;
    if (input === 'P' || input === 'PT') return false;
    return ISO_DURATION_REGEX.test(input);
  },
);
```

**tests**: `src/domain.operations/checks/isIsoDurationWords.test.ts`
- valid: PT5S, P1Y2M3DT4H5M6S, P0D, PT0.5S, P100Y, PT9999H
- invalid: 5S, PT, P, pt5s, P5S, PT5M3S2H, hello, ""

#### 1.2 create isIsoDurationShape guard

**file**: `src/domain.operations/checks/isIsoDurationShape.ts`

```ts
import { withAssure } from 'type-fns';
import type { IsoDurationShape } from '@src/domain.objects/IsoDurationShape';

const VALID_KEYS = ['years', 'months', 'weeks', 'days', 'hours', 'minutes', 'seconds', 'milliseconds'];

/**
 * .what = validates value is duration object shape
 * .why = runtime validation for external input
 */
export const isIsoDurationShape = withAssure(
  (input: unknown): input is IsoDurationShape => {
    if (typeof input !== 'object' || input === null) return false;
    const keys = Object.keys(input);
    if (keys.length === 0) return false;
    return keys.every((k) => VALID_KEYS.includes(k) && typeof (input as any)[k] === 'number');
  },
);
```

**tests**: `src/domain.operations/checks/isIsoDurationShape.test.ts`
- valid: { seconds: 5 }, { hours: 1, minutes: 30 }, { years: 1, months: 6 }
- invalid: {}, null, "PT5S", { foo: 1 }, { seconds: "5" }

#### 1.3 create isIsoDuration guard

**file**: `src/domain.operations/checks/isIsoDuration.ts`

```ts
import { withAssure } from 'type-fns';
import type { IsoDuration } from '@src/domain.objects/IsoDuration';
import { isIsoDurationWords } from './isIsoDurationWords';
import { isIsoDurationShape } from './isIsoDurationShape';

/**
 * .what = validates value is any duration format
 * .why = unified guard for polymorphic duration handle
 */
export const isIsoDuration = withAssure(
  (input: unknown): input is IsoDuration =>
    isIsoDurationWords(input) || isIsoDurationShape(input),
);
```

**tests**: `src/domain.operations/checks/isIsoDuration.test.ts`
- accepts both string and object formats
- rejects invalid inputs

---

### phase 2: cast operations

implement bidirectional conversion between formats.

#### 2.1 create asIsoDurationShape cast

**file**: `src/domain.operations/casts/asIsoDurationShape.ts`

```ts
import { BadRequestError } from 'helpful-errors';
import type { IsoDurationWords } from '@src/domain.objects/IsoDurationWords';
import type { IsoDurationShape } from '@src/domain.objects/IsoDurationShape';
import { isIsoDurationWords } from '@src/domain.operations/checks/isIsoDurationWords';

const ISO_DURATION_REGEX = /^P(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/;

/**
 * .what = parses iso 8601 string to duration object
 * .why = enables manipulation of string durations
 */
export const asIsoDurationShape = (input: IsoDurationWords): IsoDurationShape => {
  if (!isIsoDurationWords(input))
    throw new BadRequestError('invalid iso duration string', { input });

  const match = input.match(ISO_DURATION_REGEX);
  if (!match) throw new BadRequestError('failed to parse iso duration', { input });

  const [, years, months, weeks, days, hours, minutes, seconds] = match;

  const shape: IsoDurationShape = {
    ...(years && { years: parseInt(years, 10) }),
    ...(months && { months: parseInt(months, 10) }),
    ...(weeks && { weeks: parseInt(weeks, 10) }),
    ...(days && { days: parseInt(days, 10) }),
    ...(hours && { hours: parseInt(hours, 10) }),
    ...(minutes && { minutes: parseInt(minutes, 10) }),
    ...(seconds && { seconds: parseFloat(seconds) }),
  } as IsoDurationShape;

  // handle zero duration
  if (Object.keys(shape).length === 0) return { seconds: 0 } as IsoDurationShape;

  return shape;
};
```

**tests**: `src/domain.operations/casts/asIsoDurationShape.test.ts`
- PT5S → { seconds: 5 }
- P1Y6M → { years: 1, months: 6 }
- P1DT2H30M → { days: 1, hours: 2, minutes: 30 }
- PT1.5S → { seconds: 1.5 }
- PT0S → { seconds: 0 }
- invalid input throws BadRequestError

#### 2.2 create asIsoDurationWords cast

**file**: `src/domain.operations/casts/asIsoDurationWords.ts`

```ts
import type { IsoDurationWords } from '@src/domain.objects/IsoDurationWords';
import type { IsoDurationShape } from '@src/domain.objects/IsoDurationShape';

/**
 * .what = converts duration object to iso 8601 string
 * .why = enables serialization and display of durations
 */
export const asIsoDurationWords = (input: IsoDurationShape): IsoDurationWords => {
  const parts: string[] = ['P'];

  // date components
  if (input.years) parts.push(`${input.years}Y`);
  if (input.months) parts.push(`${input.months}M`);
  if (input.weeks) parts.push(`${input.weeks}W`);
  if (input.days) parts.push(`${input.days}D`);

  // time components
  const seconds = (input.seconds ?? 0) + (input.milliseconds ?? 0) / 1000;
  const hasTime = input.hours || input.minutes || seconds;

  if (hasTime) {
    parts.push('T');
    if (input.hours) parts.push(`${input.hours}H`);
    if (input.minutes) parts.push(`${input.minutes}M`);
    if (seconds) {
      // format seconds: remove zeros after decimal
      const formatted = seconds % 1 === 0 ? `${seconds}` : `${seconds}`.replace(/\.?0+$/, '');
      parts.push(`${formatted}S`);
    }
  }

  // handle zero duration
  if (parts.length === 1) return 'PT0S' as IsoDurationWords;

  return parts.join('') as IsoDurationWords;
};
```

**tests**: `src/domain.operations/casts/asIsoDurationWords.test.ts`
- { seconds: 5 } → "PT5S"
- { years: 1, months: 6 } → "P1Y6M"
- { days: 1, hours: 2, minutes: 30 } → "P1DT2H30M"
- { milliseconds: 500 } → "PT0.5S"
- { seconds: 1, milliseconds: 500 } → "PT1.5S"
- { seconds: 0 } → "PT0S"
- { weeks: 2 } → "P2W"
- { weeks: 2, days: 3 } → "P2W3D"

---

### phase 3: update operations

modify operations to accept IsoDuration (both formats).

#### 3.1 create asIsoDurationShape helper

**file**: `src/domain.operations/casts/asIsoDurationShape.ts`

```ts
import type { IsoDuration } from '@src/domain.objects/IsoDuration';
import type { IsoDurationShape } from '@src/domain.objects/IsoDurationShape';
import { isIsoDurationWords } from '@src/domain.operations/checks/isIsoDurationWords';
import { asIsoDurationShape } from './asIsoDurationShape';

/**
 * .what = normalizes any duration to object shape
 * .why = internal helper for operations that need object format
 */
export const asIsoDurationShape = (input: IsoDuration): IsoDurationShape =>
  isIsoDurationWords(input) ? asIsoDurationShape(input) : input;
```

**tests**: `src/domain.operations/casts/asIsoDurationShape.test.ts`
- string input returns parsed object
- object input returns as-is

#### 3.2 update toMilliseconds

**file**: `src/domain.operations/manipulate/toMilliseconds.ts`

```ts
// add import
import { asIsoDurationShape } from '@src/domain.operations/casts/asIsoDurationShape';

// update signature and implementation
export const toMilliseconds = (duration: IsoDuration): number => {
  const shape = asIsoDurationShape(duration);
  // ... rest unchanged, use shape instead of duration
};
```

**tests**: add to `src/domain.operations/manipulate/toMilliseconds.test.ts`
- toMilliseconds("PT1H") === 3600000
- toMilliseconds("PT1H30M") === toMilliseconds({ hours: 1, minutes: 30 })

#### 3.3 update addDuration

**file**: `src/domain.operations/manipulate/addDuration.ts`

- update signature to accept `IsoDuration`
- normalize input via `asIsoDurationShape`

**tests**: add to `src/domain.operations/manipulate/addDuration.test.ts`
- addDuration(stamp, "PT1H") works
- addDuration(stamp, "PT1H") === addDuration(stamp, { hours: 1 })

#### 3.4 update subDuration

**file**: `src/domain.operations/manipulate/subDuration.ts`

- update signature to accept `IsoDuration`
- normalize input via `asIsoDurationShape`

**tests**: add to `src/domain.operations/manipulate/subDuration.test.ts`
- subDuration(stamp, "PT1H") works
- subDuration(stamp, "PT1H") === subDuration(stamp, { hours: 1 })

#### 3.5 update asDurationInWords

**file**: `src/domain.operations/manipulate/asDurationInWords.ts`

- update signature to accept `IsoDuration`
- normalize input via `asIsoDurationShape`

**tests**: add to `src/domain.operations/manipulate/asDurationInWords.test.ts`
- asDurationInWords("PT2H5M") === "2h 5m"

#### 3.6 update sleep

**file**: `src/domain.operations/utils/sleep.ts`

- signature already accepts `IsoDuration` via toMilliseconds
- no change needed if toMilliseconds is updated

**tests**: add to sleep tests
- sleep("PT0.01S") works

#### 3.7 update waitFor

**file**: `src/domain.operations/wrappers/waitFor.ts`

- options already typed as `IsoDuration`
- no change needed if toMilliseconds is updated

**tests**: add to waitFor tests
- waitFor(fn, { interval: "PT0.01S", timeout: "PT1S" }) works

---

### phase 4: exports

update public api to expose new types and operations.

#### 4.1 update index.ts

**file**: `src/index.ts`

```ts
// domain objects
export * from './domain.objects/IsoDuration';
export * from './domain.objects/IsoDurationWords';
export * from './domain.objects/IsoDurationShape';

// checks — duration validators
export * from './domain.operations/checks/isIsoDuration';
export * from './domain.operations/checks/isIsoDurationWords';
export * from './domain.operations/checks/isIsoDurationShape';

// casts — duration converters
export * from './domain.operations/casts/asIsoDurationShape';
export * from './domain.operations/casts/asIsoDurationWords';

// ... current exports
```

---

### phase 5: acceptance tests

verify end-to-end behavior via blackbox tests.

#### 5.1 update acceptance tests

**file**: `blackbox/iso-time.acceptance.test.ts`

add new test cases:

```ts
given('iso duration string support', () => {
  when('duration declared via string format', () => {
    then('type accepts valid patterns', () => {
      const d1: IsoDuration = 'PT5S';
      const d2: IsoDuration = 'P1Y6M';
      const d3: IsoDuration = 'P1DT2H30M';
      expect(d1).toBeDefined();
      expect(d2).toBeDefined();
      expect(d3).toBeDefined();
    });
  });

  when('duration strings validated', () => {
    then('isIsoDurationWords validates correctly', () => {
      expect(isIsoDurationWords('PT5S')).toBe(true);
      expect(isIsoDurationWords('invalid')).toBe(false);
    });
  });

  when('formats converted', () => {
    then('round-trip preserves values', () => {
      const original: IsoDurationShape = { hours: 2, minutes: 30 };
      const asString = asIsoDurationWords(original);
      const backToShape = asIsoDurationShape(asString);
      expect(backToShape).toEqual(original);
    });
  });

  when('operations called with string durations', () => {
    then('addDuration accepts string format', () => {
      const start = asIsoTimeStamp('2024-01-01T00:00:00Z');
      const result = addDuration(start, 'PT1H');
      expect(result).toEqual(asIsoTimeStamp('2024-01-01T01:00:00Z'));
    });

    then('toMilliseconds accepts string format', () => {
      expect(toMilliseconds('PT1H')).toEqual(3600000);
    });

    then('both formats produce identical results', () => {
      const stamp = asIsoTimeStamp('2024-01-01T00:00:00Z');
      const resultStr = addDuration(stamp, 'PT1H30M');
      const resultObj = addDuration(stamp, { hours: 1, minutes: 30 });
      expect(resultStr).toEqual(resultObj);
    });
  });
});
```

---

## test coverage summary

| component | unit | integration | acceptance |
|-----------|------|-------------|------------|
| IsoDurationWords type | ✓ | - | ✓ |
| IsoDurationShape type | ✓ | - | ✓ |
| IsoDuration union | ✓ | - | ✓ |
| isIsoDurationWords | ✓ | - | ✓ |
| isIsoDurationShape | ✓ | - | - |
| isIsoDuration | ✓ | - | - |
| asIsoDurationShape | ✓ | - | ✓ |
| asIsoDurationWords | ✓ | - | ✓ |
| toMilliseconds (updated) | ✓ | - | ✓ |
| addDuration (updated) | ✓ | ✓ | ✓ |
| subDuration (updated) | ✓ | - | - |
| asDurationInWords (updated) | ✓ | - | - |
| sleep (string format) | - | ✓ | - |
| waitFor (string format) | - | ✓ | - |

---

## file changes summary

### new files
- `src/domain.objects/IsoDurationWords.ts`
- `src/domain.objects/IsoDurationWords.test.ts`
- `src/domain.objects/IsoDurationShape.ts`
- `src/domain.objects/IsoDurationShape.test.ts`
- `src/domain.operations/checks/isIsoDurationWords.ts`
- `src/domain.operations/checks/isIsoDurationWords.test.ts`
- `src/domain.operations/checks/isIsoDurationShape.ts`
- `src/domain.operations/checks/isIsoDurationShape.test.ts`
- `src/domain.operations/checks/isIsoDuration.ts`
- `src/domain.operations/checks/isIsoDuration.test.ts`
- `src/domain.operations/casts/asIsoDurationShape.ts`
- `src/domain.operations/casts/asIsoDurationShape.test.ts`
- `src/domain.operations/casts/asIsoDurationWords.ts`
- `src/domain.operations/casts/asIsoDurationWords.test.ts`
- `src/domain.operations/casts/asIsoDurationShape.ts`
- `src/domain.operations/casts/asIsoDurationShape.test.ts`

### modified files
- `src/domain.objects/IsoDuration.ts` (update to union type)
- `src/domain.objects/IsoDuration.test.ts` (update tests)
- `src/domain.operations/manipulate/toMilliseconds.ts`
- `src/domain.operations/manipulate/addDuration.ts`
- `src/domain.operations/manipulate/subDuration.ts`
- `src/domain.operations/manipulate/asDurationInWords.ts`
- `src/index.ts` (add exports)
- `blackbox/iso-time.acceptance.test.ts` (add tests)

---

## execution order

1. phase 0: domain objects (foundation)
2. phase 1: type guards (validation)
3. phase 2: cast operations (conversion)
4. phase 3: update operations (integration)
5. phase 4: exports (public api)
6. phase 5: acceptance tests (verification)

each phase should pass all tests before proceed to the next.
