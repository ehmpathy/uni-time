# blueprint criteria: iso duration string support

mechanism bounds to deliver the blackbox experience

---

## blackbox criteria satisfied

- usecase.1 = declare duration via string format ✓
- usecase.2 = declare duration via object format (current behavior) ✓
- usecase.3 = validate duration strings ✓
- usecase.4 = cast string to duration and vice versa ✓
- usecase.5 = operations accept both formats isomorphically ✓
- usecase.6 = getDuration returns duration shape (not string) ✓
- usecase.7 = asDurationInWords supports both formats ✓
- usecase.8 = edge cases and boundary conditions ✓
- usecase.9 = type guards narrow IsoDuration type ✓
- usecase.10 = stopwatch returns duration object ✓

---

## subcomponent contracts

### domain objects

given('IsoDurationWords type contract')
  then('uses typescript template literal types to union valid patterns')
  then('enables compile-time validation of duration string literals')
  then('is exported from src/domain.objects/')

  // time-only examples the type must accept:
  // - "PT5S"           (seconds)
  // - "PT30M"          (minutes)
  // - "PT2H"           (hours)
  // - "PT2H30M"        (hours + minutes)
  // - "PT2H45S"        (hours + seconds)
  // - "PT30M15S"       (minutes + seconds)
  // - "PT2H30M45S"     (hours + minutes + seconds)
  // - "PT0.5S"         (fractional seconds)
  // - "PT1.001S"       (fractional seconds, millisecond precision)
  // - "PT0S"           (zero duration)

  // date-only examples the type must accept:
  // - "P1Y"            (years)
  // - "P6M"            (months)
  // - "P2W"            (weeks)
  // - "P30D"           (days)
  // - "P1Y6M"          (years + months)
  // - "P1Y30D"         (years + days)
  // - "P6M15D"         (months + days)
  // - "P1Y6M15D"       (years + months + days)
  // - "P2W3D"          (weeks + days)

  // combined examples the type must accept:
  // - "P1DT2H"         (days + hours)
  // - "P1DT30M"        (days + minutes)
  // - "P1DT2H30M"      (days + hours + minutes)
  // - "P1YT12H"        (years + hours)
  // - "P1Y6MT2H30M"    (years + months + hours + minutes)
  // - "P1Y6M15DT12H30M45S"    (full combination)
  // - "P1Y6M15DT12H30M45.5S"  (full combination + fractional seconds)

given('IsoDurationShape type contract')
  then('is the current IsoDuration object type renamed')
  then('has optional fields: years, months, weeks, days, hours, minutes, seconds, milliseconds')
  then('is exported from src/domain.objects/')

given('IsoDuration type contract')
  then('is union: IsoDurationWords | IsoDurationShape')
  then('accepts both string and object formats')
  then('is exported from src/domain.objects/')

### type guards

given('isIsoDurationWords contract')
  then('exposes: isIsoDurationWords(value: unknown) => value is IsoDurationWords')
  then('returns true for valid iso 8601 duration strings')
  then('returns false for invalid strings')
  then('is exported from src/domain.operations/checks/')

given('isIsoDurationShape contract')
  then('exposes: isIsoDurationShape(value: unknown) => value is IsoDurationShape')
  then('returns true for valid duration objects')
  then('returns false for non-objects or invalid shapes')
  then('is exported from src/domain.operations/checks/')

given('isIsoDuration contract')
  then('exposes: isIsoDuration(value: unknown) => value is IsoDuration')
  then('returns true if isIsoDurationWords(value) or isIsoDurationShape(value)')
  then('is exported from src/domain.operations/checks/')

### cast operations

given('asIsoDurationWords contract')
  then('exposes: asIsoDurationWords(duration: IsoDurationShape) => IsoDurationWords')
  then('converts object shape to iso 8601 string format')
  then('merges milliseconds into fractional seconds')
  then('omits zero-valued units except for zero duration (PT0S)')
  then('is exported from src/domain.operations/casts/')

given('asIsoDurationShape contract')
  then('exposes: asIsoDurationShape(duration: IsoDurationWords) => IsoDurationShape')
  then('parses iso 8601 string to object shape')
  then('converts fractional seconds to seconds field (not milliseconds)')
  then('throws BadRequestError for invalid strings')
  then('is exported from src/domain.operations/casts/')

### updated operations

given('addDuration contract')
  then('exposes: addDuration(stamp, duration: IsoDuration) => stamp')
  then('accepts both IsoDurationWords and IsoDurationShape')
  then('produces identical results for equivalent formats')

given('subDuration contract')
  then('exposes: subDuration(stamp, duration: IsoDuration) => stamp')
  then('accepts both IsoDurationWords and IsoDurationShape')
  then('produces identical results for equivalent formats')

given('toMilliseconds contract')
  then('exposes: toMilliseconds(duration: IsoDuration) => number')
  then('accepts both IsoDurationWords and IsoDurationShape')
  then('produces identical results for equivalent formats')

given('sleep contract')
  then('exposes: sleep(duration: IsoDuration) => Promise<void>')
  then('accepts both IsoDurationWords and IsoDurationShape')

given('waitFor contract')
  then('exposes: waitFor(fn, options: { interval: IsoDuration, timeout: IsoDuration })')
  then('accepts both formats for interval and timeout options')

given('asDurationInWords contract')
  then('exposes: asDurationInWords(duration: IsoDuration) => string')
  then('accepts both IsoDurationWords and IsoDurationShape')
  then('produces identical results for equivalent formats')

### unchanged operations

given('getDuration contract')
  then('exposes: getDuration(input) => IsoDurationShape')
  then('returns object shape (not string)')
  then('no change required')

given('startDurationStopwatch contract')
  then('stop() returns { duration: IsoDurationShape }')
  then('returns object shape (not string)')
  then('no change required')

---

## composition boundaries

given('operations that accept IsoDuration')
  then('normalize to IsoDurationShape internally via asIsoDurationShape when input is string')
  then('process via current object-based logic')
  then('return results in same format as before (no change to return types)')

given('type union composition')
  then('IsoDuration = IsoDurationWords | IsoDurationShape')
  then('operations use overloads or union input types')
  then('type guards enable conditional logic when format matters')

---

## test coverage criteria

given('IsoDurationWords type')
  then('has unit tests for valid patterns: time-only, date-only, combined, fractional')
  then('has unit tests for invalid patterns: absent P, lowercase, wrong order, empty')

given('IsoDurationShape type')
  then('has unit tests for current behavior preservation')
  then('no new tests required beyond current coverage')

given('isIsoDurationWords guard')
  then('has unit tests for all valid pattern variants')
  then('has unit tests for all invalid pattern variants per blackbox criteria')

given('asIsoDurationWords cast')
  then('has unit tests for each unit type: Y, M, W, D, H, M, S')
  then('has unit tests for milliseconds to fractional seconds conversion')
  then('has unit tests for zero duration edge case')
  then('has unit tests for combined units')

given('asIsoDurationShape cast')
  then('has unit tests for each unit type: Y, M, W, D, H, M, S')
  then('has unit tests for fractional seconds')
  then('has unit tests for invalid input throws BadRequestError')

given('updated operations')
  then('addDuration has tests for both formats with identical results')
  then('subDuration has tests for both formats with identical results')
  then('toMilliseconds has tests for both formats with identical results')
  then('sleep has tests for string format')
  then('waitFor has tests for string format in options')
  then('asDurationInWords has tests for string format')

given('acceptance tests')
  then('blackbox/iso-time.acceptance.test.ts covers string duration declaration')
  then('blackbox/iso-time.acceptance.test.ts covers format conversion round-trip')
  then('blackbox/iso-time.acceptance.test.ts covers operations with string durations')
