# blackbox criteria: iso-time

experience bounds for users of the `iso-time` library.

---

# usecase.1 = type absolute instants with stamps

given('a user wants to represent an absolute moment in history')
  when('they import stamp types from iso-time')
    then('IsoTimeStamp accepts `yyyy-MM-ddTHH:mm:ssZ` format')
      sothat('exact instants are unambiguous')
    then('IsoDateStamp accepts `yyyy-MM-dd` format')
      sothat('exact days are unambiguous')
    then('IsoMonthStamp accepts `yyyy-MM` format')
      sothat('exact months are unambiguous')
    then('IsoYearStamp accepts `yyyy` format')
      sothat('exact years are unambiguous')

  when('they assign an invalid format to a stamp type')
    then('typescript rejects the assignment at compile time')
      sothat('format errors are caught before runtime')

---

# usecase.2 = type detached patterns with floats

given('a user wants to represent a detached time pattern')
  when('they import float types from iso-time')
    then('IsoTimeFloat accepts `HH:mm:ss` format')
      sothat('time-of-day patterns are unambiguous')
    then('IsoHourFloat accepts `HH` format')
      sothat('hour-of-day patterns are unambiguous')
    then('IsoMinuteFloat accepts `mm` format')
      sothat('minute-of-hour patterns are unambiguous')
    then('IsoMonthFloat accepts `MM` format')
      sothat('month-of-year patterns are unambiguous')
    then('IsoDayFloat accepts `dd` format')
      sothat('day-of-month patterns are unambiguous')
    then('IsoWeekdayFloat accepts `d` format (1-7, monday=1)')
      sothat('day-of-week patterns are unambiguous')

  when('they assign an invalid format to a float type')
    then('typescript rejects the assignment at compile time')
      sothat('format errors are caught before runtime')

---

# usecase.3 = add duration to stamps

given('a user has an IsoTimeStamp')
  when('they call addDuration with { hours: 2 }')
    then('they receive a new IsoTimeStamp shifted by 2 hours')
      sothat('time arithmetic is straightforward')

given('a user has an IsoDateStamp')
  when('they call addDuration with { days: 7 }')
    then('they receive a new IsoDateStamp shifted by 7 days')
      sothat('date arithmetic is straightforward')

given('a user has an IsoMonthStamp')
  when('they call addDuration with { months: 3 }')
    then('they receive a new IsoMonthStamp shifted by 3 months')
      sothat('month arithmetic is straightforward')

---

# usecase.4 = compute duration between stamps

given('a user has two IsoTimeStamps')
  when('they call getDuration with { since, until }')
    then('they receive an IsoDuration representing the difference')
      sothat('duration computation is straightforward')

given('a user has two IsoDateStamps')
  when('they call getDuration with { since, until }')
    then('they receive an IsoDuration representing the difference')
      sothat('date difference computation is straightforward')

---

# usecase.5 = represent time ranges

given('a user wants to represent a time range')
  when('they use IsoTimeStampRange')
    then('they can specify { since: IsoTimeStamp, until: IsoTimeStamp }')
      sothat('time ranges have consistent structure')

given('a user wants to represent a date range')
  when('they use IsoDateStampRange')
    then('they can specify { since: IsoDateStamp, until: IsoDateStamp }')
      sothat('date ranges have consistent structure')

---

# usecase.6 = validate stamp formats at runtime

given('a user receives a string from external input')
  when('they call isIsoTimeStamp with a valid format')
    then('it returns true')
      sothat('valid stamps are confirmed')
  when('they call isIsoTimeStamp with an invalid format')
    then('it returns false')
      sothat('invalid stamps are rejected')

given('a user receives a string from external input')
  when('they call isIsoDateStamp with a valid format')
    then('it returns true')
  when('they call isIsoDateStamp with an invalid format')
    then('it returns false')

given('a user receives a string from external input')
  when('they call isIsoMonthStamp with a valid format')
    then('it returns true')
  when('they call isIsoMonthStamp with an invalid format')
    then('it returns false')

given('a user receives a string from external input')
  when('they call isIsoYearStamp with a valid format')
    then('it returns true')
  when('they call isIsoYearStamp with an invalid format')
    then('it returns false')

---

# usecase.7 = validate float formats at runtime

given('a user receives a string from external input')
  when('they call isIsoTimeFloat with a valid format')
    then('it returns true')
  when('they call isIsoTimeFloat with an invalid format')
    then('it returns false')

given('a user receives a string from external input')
  when('they call isIsoHourFloat with a valid format')
    then('it returns true')
  when('they call isIsoHourFloat with an invalid format')
    then('it returns false')

given('a user receives a string from external input')
  when('they call isIsoMinuteFloat with a valid format')
    then('it returns true')
  when('they call isIsoMinuteFloat with an invalid format')
    then('it returns false')

given('a user receives a string from external input')
  when('they call isIsoMonthFloat with a valid format')
    then('it returns true')
  when('they call isIsoMonthFloat with an invalid format')
    then('it returns false')

given('a user receives a string from external input')
  when('they call isIsoDayFloat with a valid format')
    then('it returns true')
  when('they call isIsoDayFloat with an invalid format')
    then('it returns false')

given('a user receives a string from external input')
  when('they call isIsoWeekdayFloat with a valid format (1-7)')
    then('it returns true')
  when('they call isIsoWeekdayFloat with an invalid format (0, 8, etc)')
    then('it returns false')

---

# usecase.8 = get current time as stamps

given('a user wants the current moment')
  when('they call now()')
    then('they receive the current IsoTimeStamp in UTC')
      sothat('current time capture is straightforward')

given('a user wants the current date')
  when('they call today()')
    then('they receive the current IsoDateStamp in UTC')
      sothat('current date capture is straightforward')

---

# boundary.1 = stamp format strictness

given('a stamp type with strict format')
  when('user provides `2024-01-15T14:30:00Z`')
    then('IsoTimeStamp accepts it')
  when('user provides `2024-01-15T14:30:00` (no Z)')
    then('IsoTimeStamp rejects it')
  when('user provides `2024-01-15T14:30Z` (no seconds)')
    then('IsoTimeStamp rejects it')
  when('user provides `2024-01-15 14:30:00Z` (space instead of T)')
    then('IsoTimeStamp rejects it')

---

# boundary.2 = float format strictness

given('a float type with strict format')
  when('user provides `14:30:00`')
    then('IsoTimeFloat accepts it')
  when('user provides `14:30` (no seconds)')
    then('IsoTimeFloat rejects it')
  when('user provides `9:30:00` (single digit hour)')
    then('IsoTimeFloat rejects it')

given('IsoWeekdayFloat')
  when('user provides `1`')
    then('it accepts (monday)')
  when('user provides `7`')
    then('it accepts (sunday)')
  when('user provides `0`')
    then('it rejects')
  when('user provides `8`')
    then('it rejects')

---

# boundary.3 = duration edge cases

given('addDuration on IsoDateStamp')
  when('adding days crosses month boundary')
    then('result reflects correct month')
  when('adding months on day 31 lands on month with fewer days')
    then('result clamps to last valid day of month')

given('getDuration between stamps')
  when('since is after until')
    then('result is negative duration')
      sothat('order is not enforced, direction is preserved')

---

# boundary.4 = leap year handling

given('IsoDateStamp on 2024-02-29 (leap year)')
  when('adding 1 year')
    then('result is 2025-02-28')
      sothat('invalid dates are avoided')

given('IsoDateStamp on 2024-02-28')
  when('adding 1 year')
    then('result is 2025-02-28')
      sothat('valid dates remain valid')
