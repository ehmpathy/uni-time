# blueprint: iso-time implementation

implementation plan to transform `uni-time` into `iso-time` following the domain distillation.

---

## overview

### scope

1. **rename package** from `@ehmpathy/uni-time` to `iso-time`
2. **rename domain objects** following the `Iso{Unit}{Nature}` pattern
3. **add new domain objects** not present in uni-time
4. **maintain backwards compatibility** via migration mapping
5. **enforce thorough test coverage** for all behaviors

### migration mapping

| old (uni-time) | new (iso-time) |
|----------------|----------------|
| `UniDateTime` | `IsoTimeStamp` |
| `UniDate` | `IsoDateStamp` |
| `UniMonth` | `IsoMonthStamp` |
| `UniTime` | `IsoTimeFloat` |
| `UniDateRange` | `IsoDateStampRange` |
| `UniDateTimeRange` | `IsoTimeStampRange` |
| `UniDuration` | `IsoDuration` |
| `isUniDateTime` | `isIsoTimeStamp` |
| `isUniDate` | `isIsoDateStamp` |
| `isUniMonth` | `isIsoMonthStamp` |
| `asUniDateTime` | `asIsoTimeStamp` |
| `asUniDate` | `asIsoDateStamp` |
| `until` | `until` |

### new additions (not in uni-time)

| type | format | purpose |
|------|--------|---------|
| `IsoYearStamp` | `yyyy` | exact year in history |
| `IsoHourFloat` | `HH` | hour of day pattern |
| `IsoMinuteFloat` | `mm` | minute of hour pattern |
| `IsoMonthFloat` | `MM` | month of year pattern |
| `IsoDayFloat` | `dd` | day of month pattern |
| `IsoWeekdayFloat` | `d` | weekday pattern (1-7) |
| `now()` | — | current timestamp |
| `today()` | — | current date |

---

## phase 1: domain objects

### 1.1 stamp types (absolute instants)

**file: `src/domain.objects/IsoTimeStamp.ts`**

```ts
import type { AsOfGlossary } from 'domain-glossaries';

/**
 * .what = exact instant in history
 * .why = unambiguous UTC timestamp for events, logs, records
 * .format = yyyy-MM-ddTHH:mm:ssZ
 */
export type IsoTimeStamp = AsOfGlossary<string, 'iso-time.IsoTimeStamp'>;

/**
 * .what = exact day in history
 * .why = unambiguous date for appointments, deadlines, milestones
 * .format = yyyy-MM-dd
 */
export type IsoDateStamp = AsOfGlossary<
  string,
  'iso-time.IsoDateStamp' | 'iso-time.IsoTimeStamp'
>;

/**
 * .what = exact month in history
 * .why = unambiguous month for billing periods, reports
 * .format = yyyy-MM
 */
export type IsoMonthStamp = AsOfGlossary<string, 'iso-time.IsoMonthStamp'>;

/**
 * .what = exact year in history
 * .why = unambiguous year for annual records
 * .format = yyyy
 */
export type IsoYearStamp = AsOfGlossary<string, 'iso-time.IsoYearStamp'>;
```

**tests: `src/domain.objects/IsoTimeStamp.test.ts`**
- type composition tests (IsoTimeStamp assignable to IsoDateStamp)
- type narrowing tests (IsoDateStamp NOT assignable to IsoTimeStamp)

---

### 1.2 float types (detached patterns)

**file: `src/domain.objects/IsoTimeFloat.ts`**

```ts
import type { AsOfGlossary } from 'domain-glossaries';

/**
 * .what = time of day pattern
 * .why = detached time for schedules, store hours, standups
 * .format = HH:mm:ss
 */
export type IsoTimeFloat = AsOfGlossary<string, 'iso-time.IsoTimeFloat'>;

/**
 * .what = hour of day pattern
 * .why = detached hour for hourly schedules
 * .format = HH (00-23)
 */
export type IsoHourFloat = AsOfGlossary<string, 'iso-time.IsoHourFloat'>;

/**
 * .what = minute of hour pattern
 * .why = detached minute for minute-level patterns
 * .format = mm (00-59)
 */
export type IsoMinuteFloat = AsOfGlossary<string, 'iso-time.IsoMinuteFloat'>;

/**
 * .what = month of year pattern
 * .why = detached month for annual renewals, fiscal periods
 * .format = MM (01-12)
 */
export type IsoMonthFloat = AsOfGlossary<string, 'iso-time.IsoMonthFloat'>;

/**
 * .what = day of month pattern
 * .why = detached day for monthly due dates, paydays
 * .format = dd (01-31)
 */
export type IsoDayFloat = AsOfGlossary<string, 'iso-time.IsoDayFloat'>;

/**
 * .what = day of week pattern
 * .why = detached weekday for weekly standups, recurring events
 * .format = d (1-7, monday=1)
 */
export type IsoWeekdayFloat = AsOfGlossary<string, 'iso-time.IsoWeekdayFloat'>;
```

**tests: `src/domain.objects/IsoTimeFloat.test.ts`**
- type definition tests
- format validation tests

---

### 1.3 range types

**file: `src/domain.objects/IsoTimeStampRange.ts`**

```ts
import type { AsOfGlossary } from 'domain-glossaries';
import type { IsoTimeStamp, IsoDateStamp } from './IsoTimeStamp';

/**
 * .what = time range with since/until bounds
 * .why = represent sessions, windows, intervals
 * .note = since is inclusive, until is exclusive
 */
export type IsoTimeStampRange = AsOfGlossary<
  { since: IsoTimeStamp; until: IsoTimeStamp },
  'iso-time.IsoTimeStampRange',
  false
>;

/**
 * .what = date range with since/until bounds
 * .why = represent booking windows, periods, spans
 * .note = since is inclusive, until is exclusive
 */
export type IsoDateStampRange = AsOfGlossary<
  { since: IsoDateStamp; until: IsoDateStamp },
  'iso-time.IsoDateStampRange' | 'iso-time.IsoTimeStampRange',
  false
>;
```

**tests: `src/domain.objects/IsoTimeStampRange.test.ts`**
- range composition tests
- IsoTimeStampRange assignable to IsoDateStampRange

---

### 1.4 duration type

**file: `src/domain.objects/IsoDuration.ts`**

```ts
import type { AsOfGlossary } from 'domain-glossaries';
import type { PickAny } from 'type-fns';

/**
 * .what = duration between two instants
 * .why = represent time spans for arithmetic
 */
export type IsoDuration = AsOfGlossary<
  PickAny<{
    years: number;
    months: number;
    weeks: number;
    days: number;
    hours: number;
    minutes: number;
    seconds: number;
    milliseconds: number;
  }>,
  'iso-time.IsoDuration',
  false
>;
```

**tests: `src/domain.objects/IsoDuration.test.ts`**
- type definition tests
- PickAny flexibility tests

---

## phase 2: domain operations - checks

### 2.1 stamp validators

**file: `src/domain.operations/checks/isIsoTimeStamp.ts`**

```ts
import { format } from 'date-fns/format';
import { parseISO } from 'date-fns/parseISO';
import { withAssure } from 'type-fns';

import type { IsoTimeStamp } from '../../domain.objects/IsoTimeStamp';
import { castInputToDate } from '../casts/castInputToDate';

/**
 * .what = casts input to IsoTimeStamp format
 * .why = normalize various input types to strict ISO timestamp
 */
export const asIsoTimeStamp = (
  input: Date | string | number | { mse: number } | { date: Date },
): IsoTimeStamp =>
  format(castInputToDate(input), "yyyy-MM-dd'T'HH:mm:ss'Z'") as IsoTimeStamp;

/**
 * .what = validates string is IsoTimeStamp format
 * .why = runtime validation for external input
 */
export const isIsoTimeStamp = withAssure(
  (input: string): input is IsoTimeStamp => {
    try {
      return asIsoTimeStamp(parseISO(input)) === input;
    } catch {
      return false;
    }
  },
);
```

**tests: `src/domain.operations/checks/isIsoTimeStamp.test.ts`**

```ts
const cases = [
  { input: '2024-01-15T14:30:00Z', output: true },
  { input: '2024-01-15T14:30:00', output: false },     // no Z
  { input: '2024-01-15T14:30Z', output: false },       // no seconds
  { input: '2024-01-15 14:30:00Z', output: false },    // space instead of T
  { input: '2024-01-15', output: false },              // date only
  { input: 'invalid', output: false },
];
```

**similar pattern for:**
- `isIsoDateStamp.ts` / `isIsoDateStamp.test.ts`
- `isIsoMonthStamp.ts` / `isIsoMonthStamp.test.ts`
- `isIsoYearStamp.ts` / `isIsoYearStamp.test.ts`

---

### 2.2 float validators

**file: `src/domain.operations/checks/isIsoTimeFloat.ts`**

```ts
import { withAssure } from 'type-fns';

import type { IsoTimeFloat } from '../../domain.objects/IsoTimeFloat';

const TIME_FLOAT_REGEX = /^\d{2}:\d{2}:\d{2}$/;

/**
 * .what = validates string is IsoTimeFloat format
 * .why = runtime validation for time-of-day patterns
 */
export const isIsoTimeFloat = withAssure(
  (input: string): input is IsoTimeFloat => {
    if (!TIME_FLOAT_REGEX.test(input)) return false;

    // validate semantic ranges
    const [hours, minutes, seconds] = input.split(':').map(Number);
    if (hours < 0 || hours > 23) return false;
    if (minutes < 0 || minutes > 59) return false;
    if (seconds < 0 || seconds > 59) return false;

    return true;
  },
);
```

**tests: `src/domain.operations/checks/isIsoTimeFloat.test.ts`**

```ts
const cases = [
  { input: '14:30:00', output: true },
  { input: '00:00:00', output: true },
  { input: '23:59:59', output: true },
  { input: '14:30', output: false },         // no seconds
  { input: '9:30:00', output: false },       // single digit hour
  { input: '24:00:00', output: false },      // invalid hour
  { input: '14:60:00', output: false },      // invalid minute
];
```

**similar pattern for:**
- `isIsoHourFloat.ts` / `isIsoHourFloat.test.ts` (range: 00-23)
- `isIsoMinuteFloat.ts` / `isIsoMinuteFloat.test.ts` (range: 00-59)
- `isIsoMonthFloat.ts` / `isIsoMonthFloat.test.ts` (range: 01-12)
- `isIsoDayFloat.ts` / `isIsoDayFloat.test.ts` (range: 01-31)
- `isIsoWeekdayFloat.ts` / `isIsoWeekdayFloat.test.ts` (range: 1-7)

---

### 2.3 range validators

**file: `src/domain.operations/checks/isIsoTimeStampRange.ts`**

```ts
import { withAssure } from 'type-fns';

import type { IsoTimeStampRange } from '../../domain.objects/IsoTimeStampRange';
import { isIsoTimeStamp } from './isIsoTimeStamp';

/**
 * .what = validates object is IsoTimeStampRange shape
 * .why = runtime validation for time range structures
 */
export const isIsoTimeStampRange = withAssure(
  (input: unknown): input is IsoTimeStampRange => {
    if (typeof input !== 'object' || input === null) return false;
    if (!('since' in input) || !('until' in input)) return false;

    const { since, until } = input as { since: unknown; until: unknown };
    if (typeof since !== 'string' || typeof until !== 'string') return false;

    return isIsoTimeStamp(since) && isIsoTimeStamp(until);
  },
);
```

**similar pattern for:**
- `isIsoDateStampRange.ts` / `isIsoDateStampRange.test.ts`

---

## phase 3: domain operations - manipulate

### 3.1 duration operations

**file: `src/domain.operations/manipulate/toMilliseconds.ts`**

refactor existing `toMilliseconds.ts` to support `years` and `months` fields

**file: `src/domain.operations/manipulate/getDuration.ts`**

refactor existing `getDuration.ts` to:
- accept `{ since, until }` with new stamp types
- return `IsoDuration` with all fields including years/months

**file: `src/domain.operations/manipulate/addDuration.ts`**

refactor existing `addDuration.ts` with new overloads:

```ts
export function addDuration(stamp: IsoTimeStamp, duration: IsoDuration): IsoTimeStamp;
export function addDuration(stamp: IsoDateStamp, duration: IsoDuration): IsoDateStamp;
export function addDuration(stamp: IsoMonthStamp, duration: IsoDuration): IsoMonthStamp;
```

**file: `src/domain.operations/manipulate/subDuration.ts`**

same overload pattern as addDuration

---

### 3.2 comprehensive tests

**file: `src/domain.operations/manipulate/addDuration.test.ts`**

```ts
import { given, when, then } from 'test-fns';

describe('addDuration', () => {
  given('an IsoTimeStamp', () => {
    when('adding hours', () => {
      then('should shift the timestamp correctly', () => {
        const result = addDuration('2024-01-15T14:30:00Z', { hours: 2 });
        expect(result).toEqual('2024-01-15T16:30:00Z');
      });
    });

    when('adding days that cross month boundary', () => {
      then('should handle month rollover', () => {
        const result = addDuration('2024-01-31T12:00:00Z', { days: 1 });
        expect(result).toEqual('2024-02-01T12:00:00Z');
      });
    });
  });

  given('an IsoDateStamp', () => {
    when('adding months on day 31', () => {
      then('should clamp to last valid day', () => {
        const result = addDuration('2024-01-31', { months: 1 });
        expect(result).toEqual('2024-02-29'); // leap year
      });
    });
  });

  given('a leap year scenario', () => {
    when('adding 1 year to Feb 29', () => {
      then('should clamp to Feb 28', () => {
        const result = addDuration('2024-02-29', { years: 1 });
        expect(result).toEqual('2025-02-28');
      });
    });
  });
});
```

**file: `src/domain.operations/manipulate/getDuration.test.ts`**

```ts
describe('getDuration', () => {
  given('two IsoTimeStamps', () => {
    when('since is before until', () => {
      then('should return positive duration', () => {
        const result = getDuration({
          since: '2024-01-15T14:30:00Z',
          until: '2024-01-15T16:30:00Z',
        });
        expect(result).toEqual({ hours: 2 });
      });
    });

    when('since is after until', () => {
      then('should return negative duration', () => {
        const result = getDuration({
          since: '2024-01-15T16:30:00Z',
          until: '2024-01-15T14:30:00Z',
        });
        expect(result.hours).toBeLessThan(0);
      });
    });
  });
});
```

---

## phase 4: domain operations - observe

### 4.1 current time functions

**file: `src/domain.operations/observe/now.ts`**

```ts
import type { IsoTimeStamp } from '../../domain.objects/IsoTimeStamp';
import { asIsoTimeStamp } from '../checks/isIsoTimeStamp';

/**
 * .what = returns current UTC timestamp
 * .why = capture event times, log entries
 */
export const now = (): IsoTimeStamp => asIsoTimeStamp(new Date());
```

**file: `src/domain.operations/observe/today.ts`**

```ts
import type { IsoDateStamp } from '../../domain.objects/IsoTimeStamp';
import { asIsoDateStamp } from '../checks/isIsoDateStamp';

/**
 * .what = returns current UTC date
 * .why = capture current date for deadlines, reports
 */
export const today = (): IsoDateStamp => asIsoDateStamp(new Date());
```

**tests:**
- verify UTC timezone
- verify correct format
- mock Date for deterministic tests

---

## phase 5: domain operations - casts

### 5.1 epoch conversion

**file: `src/domain.operations/casts/toMillisecondsSinceEpoch.ts`**

refactor to accept new stamp types:

```ts
export const toMillisecondsSinceEpoch = (
  stamp: IsoTimeStamp | IsoDateStamp,
): number => new Date(stamp).getTime();

export const toMse = toMillisecondsSinceEpoch;
```

---

## phase 6: package updates

### 6.1 package.json changes

```json
{
  "name": "iso-time",
  "version": "2.0.0",
  "description": "ISO 8601 time types with stamps (absolute instants) and floats (detached patterns)",
  "keywords": ["iso8601", "timestamp", "datetime", "date", "time", "duration"]
}
```

### 6.2 index.ts exports

**file: `src/index.ts`**

```ts
// domain.objects
export * from './domain.objects/IsoTimeStamp';
export * from './domain.objects/IsoTimeFloat';
export * from './domain.objects/IsoTimeStampRange';
export * from './domain.objects/IsoDuration';

// domain.operations - casts
export * from './domain.operations/casts/castInputToDate';
export * from './domain.operations/casts/toMillisecondsSinceEpoch';

// domain.operations - checks (stamps)
export * from './domain.operations/checks/isIsoTimeStamp';
export * from './domain.operations/checks/isIsoDateStamp';
export * from './domain.operations/checks/isIsoMonthStamp';
export * from './domain.operations/checks/isIsoYearStamp';

// domain.operations - checks (floats)
export * from './domain.operations/checks/isIsoTimeFloat';
export * from './domain.operations/checks/isIsoHourFloat';
export * from './domain.operations/checks/isIsoMinuteFloat';
export * from './domain.operations/checks/isIsoMonthFloat';
export * from './domain.operations/checks/isIsoDayFloat';
export * from './domain.operations/checks/isIsoWeekdayFloat';

// domain.operations - checks (ranges)
export * from './domain.operations/checks/isIsoTimeStampRange';
export * from './domain.operations/checks/isIsoDateStampRange';

// domain.operations - manipulate
export * from './domain.operations/manipulate/addDuration';
export * from './domain.operations/manipulate/subDuration';
export * from './domain.operations/manipulate/getDuration';
export * from './domain.operations/manipulate/toMilliseconds';
export * from './domain.operations/manipulate/asDurationInWords';

// domain.operations - observe
export * from './domain.operations/observe/now';
export * from './domain.operations/observe/today';
export * from './domain.operations/observe/stopwatch/startDurationStopwatch';

// domain.operations - utils
export * from './domain.operations/utils/sleep';

// domain.operations - wrappers
export * from './domain.operations/wrappers/waitFor';
```

---

## phase 7: test coverage requirements

### 7.1 unit tests

| module | file | coverage |
|--------|------|----------|
| domain.objects | IsoTimeStamp.test.ts | type composition, assignability |
| domain.objects | IsoTimeFloat.test.ts | type composition |
| domain.objects | IsoTimeStampRange.test.ts | range composition |
| domain.objects | IsoDuration.test.ts | type flexibility |
| checks | isIsoTimeStamp.test.ts | format validation (valid/invalid) |
| checks | isIsoDateStamp.test.ts | format validation (valid/invalid) |
| checks | isIsoMonthStamp.test.ts | format validation (valid/invalid) |
| checks | isIsoYearStamp.test.ts | format validation (valid/invalid) |
| checks | isIsoTimeFloat.test.ts | format + semantic validation |
| checks | isIsoHourFloat.test.ts | range 00-23 validation |
| checks | isIsoMinuteFloat.test.ts | range 00-59 validation |
| checks | isIsoMonthFloat.test.ts | range 01-12 validation |
| checks | isIsoDayFloat.test.ts | range 01-31 validation |
| checks | isIsoWeekdayFloat.test.ts | range 1-7 validation |
| checks | isIsoTimeStampRange.test.ts | shape validation |
| checks | isIsoDateStampRange.test.ts | shape validation |
| manipulate | addDuration.test.ts | arithmetic, boundaries, leap years |
| manipulate | subDuration.test.ts | arithmetic, boundaries |
| manipulate | getDuration.test.ts | positive/negative/zero durations |
| manipulate | toMilliseconds.test.ts | all unit conversions |
| observe | now.test.ts | UTC format verification |
| observe | today.test.ts | UTC format verification |

### 7.2 integration tests

| module | file | coverage |
|--------|------|----------|
| casts | castInputToDate.integration.test.ts | all input type conversions |
| manipulate | addDuration.integration.test.ts | date-fns integration |
| observe | startDurationStopwatch.integration.test.ts | hrtime integration |

### 7.3 acceptance tests

**file: `acceptance/iso-time.acceptance.test.ts`**

```ts
import { given, when, then } from 'test-fns';

describe('iso-time', () => {
  // usecase.1: type absolute instants with stamps
  given('a user wants to represent an absolute moment', () => {
    when('they use IsoTimeStamp', () => {
      then('it accepts yyyy-MM-ddTHH:mm:ssZ format', () => {
        const stamp: IsoTimeStamp = '2024-01-15T14:30:00Z';
        expect(isIsoTimeStamp(stamp)).toBe(true);
      });
    });

    when('they use IsoDateStamp', () => {
      then('it accepts yyyy-MM-dd format', () => {
        const stamp: IsoDateStamp = '2024-01-15';
        expect(isIsoDateStamp(stamp)).toBe(true);
      });
    });
  });

  // usecase.2: type detached patterns with floats
  given('a user wants to represent a detached pattern', () => {
    when('they use IsoTimeFloat', () => {
      then('it accepts HH:mm:ss format', () => {
        const time: IsoTimeFloat = '14:30:00';
        expect(isIsoTimeFloat(time)).toBe(true);
      });
    });

    when('they use IsoWeekdayFloat', () => {
      then('it accepts 1-7 format', () => {
        expect(isIsoWeekdayFloat('1')).toBe(true);
        expect(isIsoWeekdayFloat('7')).toBe(true);
        expect(isIsoWeekdayFloat('0')).toBe(false);
        expect(isIsoWeekdayFloat('8')).toBe(false);
      });
    });
  });

  // usecase.3: add duration to stamps
  given('a user has an IsoTimeStamp', () => {
    when('they call addDuration with hours', () => {
      then('they receive a shifted IsoTimeStamp', () => {
        const result = addDuration('2024-01-15T14:30:00Z', { hours: 2 });
        expect(result).toEqual('2024-01-15T16:30:00Z');
      });
    });
  });

  // usecase.4: compute duration between stamps
  given('a user has two IsoTimeStamps', () => {
    when('they call getDuration', () => {
      then('they receive an IsoDuration', () => {
        const result = getDuration({
          since: '2024-01-15T14:30:00Z',
          until: '2024-01-15T16:30:00Z',
        });
        expect(result).toEqual({ hours: 2 });
      });
    });
  });

  // usecase.5: represent time ranges
  given('a user wants to represent a range', () => {
    when('they use IsoDateStampRange', () => {
      then('they can specify since/until', () => {
        const range: IsoDateStampRange = {
          since: '2024-01-15',
          until: '2024-01-22',
        };
        expect(isIsoDateStampRange(range)).toBe(true);
      });
    });
  });

  // usecase.6: validate stamp formats
  given('a user receives external input', () => {
    when('they call isIsoTimeStamp with valid format', () => {
      then('it returns true', () => {
        expect(isIsoTimeStamp('2024-01-15T14:30:00Z')).toBe(true);
      });
    });

    when('they call isIsoTimeStamp with invalid format', () => {
      then('it returns false', () => {
        expect(isIsoTimeStamp('2024-01-15T14:30:00')).toBe(false);
        expect(isIsoTimeStamp('2024-01-15')).toBe(false);
      });
    });
  });

  // usecase.7: validate float formats
  given('a user validates float patterns', () => {
    when('they call isIsoTimeFloat with valid format', () => {
      then('it returns true', () => {
        expect(isIsoTimeFloat('14:30:00')).toBe(true);
      });
    });

    when('they call isIsoTimeFloat with invalid format', () => {
      then('it returns false', () => {
        expect(isIsoTimeFloat('14:30')).toBe(false);
        expect(isIsoTimeFloat('9:30:00')).toBe(false);
      });
    });
  });

  // usecase.8: get current time
  given('a user wants the current moment', () => {
    when('they call now()', () => {
      then('they receive an IsoTimeStamp', () => {
        const result = now();
        expect(isIsoTimeStamp(result)).toBe(true);
      });
    });

    when('they call today()', () => {
      then('they receive an IsoDateStamp', () => {
        const result = today();
        expect(isIsoDateStamp(result)).toBe(true);
      });
    });
  });

  // boundary.1: stamp format strictness
  given('strict IsoTimeStamp format', () => {
    then('rejects missing Z', () => {
      expect(isIsoTimeStamp('2024-01-15T14:30:00')).toBe(false);
    });

    then('rejects missing seconds', () => {
      expect(isIsoTimeStamp('2024-01-15T14:30Z')).toBe(false);
    });

    then('rejects space instead of T', () => {
      expect(isIsoTimeStamp('2024-01-15 14:30:00Z')).toBe(false);
    });
  });

  // boundary.3: duration edge cases
  given('addDuration crosses month boundary', () => {
    then('result reflects correct month', () => {
      const result = addDuration('2024-01-31', { days: 1 });
      expect(result).toEqual('2024-02-01');
    });
  });

  // boundary.4: leap year handling
  given('IsoDateStamp on 2024-02-29 (leap year)', () => {
    when('adding 1 year', () => {
      then('result is 2025-02-28', () => {
        const result = addDuration('2024-02-29', { years: 1 });
        expect(result).toEqual('2025-02-28');
      });
    });
  });
});
```

---

## phase 8: implementation order

### step 1: domain objects (day 1)
1. create `IsoTimeStamp.ts` with all stamp types
2. create `IsoTimeFloat.ts` with all float types
3. create `IsoTimeStampRange.ts` with range types
4. update `IsoDuration.ts` with years/months
5. add unit tests for type composition

### step 2: checks - stamps (day 2)
1. create `isIsoTimeStamp.ts` (refactor from isUniDateTime)
2. create `isIsoDateStamp.ts` (refactor from isUniDate)
3. create `isIsoMonthStamp.ts` (refactor from isUniMonth)
4. create `isIsoYearStamp.ts` (new)
5. add unit tests for all

### step 3: checks - floats (day 3)
1. create `isIsoTimeFloat.ts` (refactor from isUniTime if exists)
2. create `isIsoHourFloat.ts` (new)
3. create `isIsoMinuteFloat.ts` (new)
4. create `isIsoMonthFloat.ts` (new)
5. create `isIsoDayFloat.ts` (new)
6. create `isIsoWeekdayFloat.ts` (new)
7. add unit tests for all

### step 4: checks - ranges (day 4)
1. create `isIsoTimeStampRange.ts` (refactor from isUniDateTimeRange)
2. create `isIsoDateStampRange.ts` (refactor from isUniDateRange)
3. add unit tests for all

### step 5: manipulate operations (day 5)
1. update `addDuration.ts` with new types and overloads
2. update `subDuration.ts` with new types and overloads
3. update `getDuration.ts` with new types
4. update `toMilliseconds.ts` with years/months support
5. add comprehensive unit tests

### step 6: observe operations (day 6)
1. create `now.ts`
2. create `today.ts`
3. update `startDurationStopwatch.ts` with new types
4. add unit tests

### step 7: casts & exports (day 7)
1. update `toMillisecondsSinceEpoch.ts`
2. update `castInputToDate.ts` if needed
3. update `src/index.ts` with all new exports
4. update `package.json`

### step 8: integration tests (day 8)
1. add integration tests for date-fns usage
2. add integration tests for casts
3. verify all boundary conditions

### step 9: acceptance tests (day 9)
1. create acceptance test suite
2. cover all blackbox use cases
3. cover all boundary cases

### step 10: cleanup & documentation (day 10)
1. remove old uni-time aliases (or keep as deprecated exports)
2. update README
3. run full test suite
4. verify build

---

## file structure (final)

```
src/
  domain.objects/
    IsoTimeStamp.ts              # IsoTimeStamp, IsoDateStamp, IsoMonthStamp, IsoYearStamp
    IsoTimeStamp.test.ts
    IsoTimeFloat.ts              # IsoTimeFloat, IsoHourFloat, IsoMinuteFloat, IsoMonthFloat, IsoDayFloat, IsoWeekdayFloat
    IsoTimeFloat.test.ts
    IsoTimeStampRange.ts         # IsoTimeStampRange, IsoDateStampRange
    IsoTimeStampRange.test.ts
    IsoDuration.ts               # IsoDuration
    IsoDuration.test.ts

  domain.operations/
    casts/
      castInputToDate.ts
      toMillisecondsSinceEpoch.ts

    checks/
      isIsoTimeStamp.ts
      isIsoTimeStamp.test.ts
      isIsoDateStamp.ts
      isIsoDateStamp.test.ts
      isIsoMonthStamp.ts
      isIsoMonthStamp.test.ts
      isIsoYearStamp.ts
      isIsoYearStamp.test.ts
      isIsoTimeFloat.ts
      isIsoTimeFloat.test.ts
      isIsoHourFloat.ts
      isIsoHourFloat.test.ts
      isIsoMinuteFloat.ts
      isIsoMinuteFloat.test.ts
      isIsoMonthFloat.ts
      isIsoMonthFloat.test.ts
      isIsoDayFloat.ts
      isIsoDayFloat.test.ts
      isIsoWeekdayFloat.ts
      isIsoWeekdayFloat.test.ts
      isIsoTimeStampRange.ts
      isIsoTimeStampRange.test.ts
      isIsoDateStampRange.ts
      isIsoDateStampRange.test.ts

    manipulate/
      addDuration.ts
      addDuration.test.ts
      subDuration.ts
      subDuration.test.ts
      getDuration.ts
      getDuration.test.ts
      toMilliseconds.ts
      toMilliseconds.test.ts
      asDurationInWords.ts
      asDurationInWords.test.ts

    observe/
      now.ts
      now.test.ts
      today.ts
      today.test.ts
      stopwatch/
        startDurationStopwatch.ts
        startDurationStopwatch.integration.test.ts

    utils/
      sleep.ts

    wrappers/
      waitFor.ts

  index.ts

acceptance/
  iso-time.acceptance.test.ts
```

---

## success criteria

1. **all blackbox use cases pass** (8 use cases)
2. **all boundary cases pass** (4 boundary cases)
3. **100% unit test coverage** for domain operations
4. **type composition verified** at compile time
5. **backwards compatibility** via migration mapping (optional deprecated exports)
6. **build passes** with no errors
7. **lint/format passes** with no violations
