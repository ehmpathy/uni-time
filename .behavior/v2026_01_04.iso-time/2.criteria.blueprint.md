# blueprint criteria: iso-time

mechanism bounds that deliver the blackbox experience.

---

## blackbox criteria satisfied

- usecase.1 = type absolute instants with stamps ✓
- usecase.2 = type detached patterns with floats ✓
- usecase.3 = add duration to stamps ✓
- usecase.4 = compute duration between stamps ✓
- usecase.5 = represent time ranges ✓
- usecase.6 = validate stamp formats at runtime ✓
- usecase.7 = validate float formats at runtime ✓
- usecase.8 = get current time as stamps ✓
- boundary.1 = stamp format strictness ✓
- boundary.2 = float format strictness ✓
- boundary.3 = duration edge cases ✓
- boundary.4 = leap year handling ✓

---

## subcomponent contracts

### stamp type contracts

given('IsoTimeStamp type contract')
  then('is a branded string type')
  then('format: `yyyy-MM-ddTHH:mm:ssZ`')
  then('regex: `/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z$/`')

given('IsoDateStamp type contract')
  then('is a branded string type')
  then('format: `yyyy-MM-dd`')
  then('regex: `/^\d{4}-\d{2}-\d{2}$/`')

given('IsoMonthStamp type contract')
  then('is a branded string type')
  then('format: `yyyy-MM`')
  then('regex: `/^\d{4}-\d{2}$/`')

given('IsoYearStamp type contract')
  then('is a branded string type')
  then('format: `yyyy`')
  then('regex: `/^\d{4}$/`')

### float type contracts

given('IsoTimeFloat type contract')
  then('is a branded string type')
  then('format: `HH:mm:ss`')
  then('regex: `/^\d{2}:\d{2}:\d{2}$/`')

given('IsoHourFloat type contract')
  then('is a branded string type')
  then('format: `HH`')
  then('regex: `/^\d{2}$/`')
  then('range: 00-23')

given('IsoMinuteFloat type contract')
  then('is a branded string type')
  then('format: `mm`')
  then('regex: `/^\d{2}$/`')
  then('range: 00-59')

given('IsoMonthFloat type contract')
  then('is a branded string type')
  then('format: `MM`')
  then('regex: `/^\d{2}$/`')
  then('range: 01-12')

given('IsoDayFloat type contract')
  then('is a branded string type')
  then('format: `dd`')
  then('regex: `/^\d{2}$/`')
  then('range: 01-31')

given('IsoWeekdayFloat type contract')
  then('is a branded string type')
  then('format: `d`')
  then('regex: `/^[1-7]$/`')
  then('range: 1-7, monday=1')

### range type contracts

given('IsoTimeStampRange type contract')
  then('shape: { since: IsoTimeStamp; until: IsoTimeStamp }')

given('IsoDateStampRange type contract')
  then('shape: { since: IsoDateStamp; until: IsoDateStamp }')

### duration type contract

given('IsoDuration type contract')
  then('is a branded string type')
  then('format: ISO 8601 duration (e.g., `PT2H`, `P7D`)')

### operation contracts

given('addDuration operation contract')
  then('exposes: addDuration(stamp: IsoTimeStamp, duration: DurationInput) => IsoTimeStamp')
  then('exposes: addDuration(stamp: IsoDateStamp, duration: DurationInput) => IsoDateStamp')
  then('exposes: addDuration(stamp: IsoMonthStamp, duration: DurationInput) => IsoMonthStamp')
  then('DurationInput shape: { years?, months?, days?, hours?, minutes?, seconds? }')
  then('handles month boundary crossings correctly')
  then('handles leap year edge cases correctly')
  then('clamps invalid dates (e.g., day 31 → day 30)')

given('getDuration operation contract')
  then('exposes: getDuration({ since: IsoTimeStamp, until: IsoTimeStamp }) => IsoDuration')
  then('exposes: getDuration({ since: IsoDateStamp, until: IsoDateStamp }) => IsoDuration')
  then('returns negative duration when since > until')

given('now operation contract')
  then('exposes: now() => IsoTimeStamp')
  then('returns current UTC time')

given('today operation contract')
  then('exposes: today() => IsoDateStamp')
  then('returns current UTC date')

### validator contracts

given('stamp validator contracts')
  then('exposes: isIsoTimeStamp(input: string) => input is IsoTimeStamp')
  then('exposes: isIsoDateStamp(input: string) => input is IsoDateStamp')
  then('exposes: isIsoMonthStamp(input: string) => input is IsoMonthStamp')
  then('exposes: isIsoYearStamp(input: string) => input is IsoYearStamp')
  then('validates format AND semantic validity (e.g., month 01-12)')

given('float validator contracts')
  then('exposes: isIsoTimeFloat(input: string) => input is IsoTimeFloat')
  then('exposes: isIsoHourFloat(input: string) => input is IsoHourFloat')
  then('exposes: isIsoMinuteFloat(input: string) => input is IsoMinuteFloat')
  then('exposes: isIsoMonthFloat(input: string) => input is IsoMonthFloat')
  then('exposes: isIsoDayFloat(input: string) => input is IsoDayFloat')
  then('exposes: isIsoWeekdayFloat(input: string) => input is IsoWeekdayFloat')
  then('validates format AND semantic validity (e.g., hour 00-23)')

---

## composition boundaries

given('type exports')
  then('all stamp types exported from root')
  then('all float types exported from root')
  then('all range types exported from root')
  then('IsoDuration exported from root')

given('operation exports')
  then('addDuration exported from root')
  then('getDuration exported from root')
  then('now exported from root')
  then('today exported from root')

given('validator exports')
  then('all isIso* validators exported from root')

given('date-fns dependency')
  then('operations compose with date-fns for arithmetic')
  then('date-fns usage is internal implementation detail')
  then('users never interact with date-fns directly')

---

## test coverage criteria

given('stamp types')
  then('unit tests for format validation regex')
  then('unit tests for semantic validation (valid month, day, hour ranges)')

given('float types')
  then('unit tests for format validation regex')
  then('unit tests for semantic validation (valid ranges)')

given('addDuration operation')
  then('unit tests for basic arithmetic')
  then('unit tests for month boundary crossings')
  then('unit tests for year boundary crossings')
  then('unit tests for leap year edge cases')
  then('unit tests for day clamping')

given('getDuration operation')
  then('unit tests for positive durations')
  then('unit tests for negative durations')
  then('unit tests for zero duration')

given('validators')
  then('unit tests for valid inputs return true')
  then('unit tests for invalid format inputs return false')
  then('unit tests for invalid semantic inputs return false')

given('now and today operations')
  then('unit tests verify UTC timezone')
  then('unit tests verify correct format')

given('acceptance coverage')
  then('acceptance tests for each blackbox usecase')
  then('acceptance tests for each blackbox boundary case')
