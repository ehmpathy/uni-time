# distill.domain.sumDurations

## usecases

### uc1: sum multiple durations from stopwatch measurements
```ts
const durationOne = stopwatch.measure(() => doTaskOne());
const durationTwo = stopwatch.measure(() => doTaskTwo());
const durationThree = stopwatch.measure(() => doTaskThree());
const totalDuration = sumDurations(durationOne, durationTwo, durationThree);
```

### uc2: sum durations from an array (e.g., mapped from data)
```ts
const tasks = await getTasks();
const durations = tasks.map((task) => task.duration);
const totalDuration = sumDurations(durations);
```

### uc3: sum durations in string format (iso 8601)
```ts
const totalDuration = sumDurations('PT1H', 'PT30M', 'PT15S');
// => { hours: 1, minutes: 30, seconds: 15 }
```

### uc4: sum mixed formats (string + object)
```ts
const totalDuration = sumDurations('PT1H', { minutes: 30 }, 'PT15S');
// => { hours: 1, minutes: 30, seconds: 15 }
```

### uc5: get sum in a specific unit
```ts
const totalMinutes = sumDurations(durations, { as: 'minutes' });
// => { minutes: 90.25 }
```

---

## contract

```ts
/**
 * .what = sums multiple iso durations into one
 * .why = enables duration arithmetic for total elapsed time
 */
export function sumDurations(
  ...durations: IsoDuration[]
): IsoDurationShape;

export function sumDurations(
  durations: IsoDuration[],
): IsoDurationShape;

export function sumDurations(
  durations: IsoDuration[],
  options: { as: keyof IsoDurationShape },
): IsoDurationShape;

export function sumDurations(
  ...durationsAndOptions: [...IsoDuration[], { as: keyof IsoDurationShape }]
): IsoDurationShape;
```

---

## domain.objects

### entities
none required — durations are value objects (literals), not entities with identity

### events
none required — this is a pure computation, no side effects

### literals

#### reuse from codebase
- **IsoDuration** — union type that accepts both formats
  - `IsoDurationWords` — iso 8601 string format (e.g., `"PT1H30M"`)
  - `IsoDurationShape` — object format with unit fields

```ts
// already defined in src/domain.objects/IsoDuration.ts
export type IsoDuration = AsOfGlossary<
  IsoDurationWords | IsoDurationShape,
  'iso-time.IsoDuration',
  false
>;
```

no new domain objects needed — the operation works entirely with current types

---

## domain.operations

### reuse from codebase
- **asIsoDurationShape** — normalizes any `IsoDuration` to `IsoDurationShape`
- **toMilliseconds** — converts any `IsoDuration` to milliseconds for arithmetic
- **getDuration** — creates `IsoDurationShape` from milliseconds (for output)

### new operation

#### sumDurations
- **location**: `src/domain.operations/manipulate/sumDurations.ts`
- **pattern**: pure computation leaf operation
- **input**: spread or array of `IsoDuration`, optional `{ as: keyof IsoDurationShape }`
- **output**: `IsoDurationShape`

---

## relationships

```
IsoDuration (input)
    │
    ├── IsoDurationWords (string format)
    │         │
    │         └──► asIsoDurationShape ──► IsoDurationShape
    │
    └── IsoDurationShape (object format)
              │
              └──► [passthrough]
              │
              ▼
      sumDurations (new operation)
              │
              ├── toMilliseconds (sum all)
              │
              └── getDuration (format output)
                        │
                        ▼
                IsoDurationShape (output)
```

### treestruct of operations
```
domain.operations/
  manipulate/
    addDuration.ts      # current: stamp + duration → stamp
    subDuration.ts      # current: stamp - duration → stamp
    getDuration.ts      # current: range → duration
    sumDurations.ts     # NEW: duration[] → duration
    toMilliseconds.ts   # current: duration → milliseconds
```

### dependencies
```
sumDurations
  ├── depends on: asIsoDurationShape (normalize inputs)
  ├── depends on: toMilliseconds (for arithmetic)
  └── depends on: getDuration (for output format)
```

---

## composition to fulfill wish

the wish asks for "sumDurations; accept either a spread or an array of IsoDuration as the input"

### implementation approach

1. **input parse** — use function overloads to accept:
   - spread: `sumDurations(d1, d2, d3)`
   - array: `sumDurations([d1, d2, d3])`
   - mixed with options: `sumDurations(d1, d2, { as: 'minutes' })`

2. **normalization** — convert each input to milliseconds via `toMilliseconds()`

3. **summation** — sum all milliseconds values

4. **output** — convert total milliseconds back to `IsoDurationShape` via `getDuration({ of: { milliseconds: total }, as })`

### code sketch

```ts
import type { IsoDuration } from '@src/domain.objects/IsoDuration';
import type { IsoDurationShape } from '@src/domain.objects/IsoDurationShape';
import { getDuration } from '@src/domain.operations/manipulate/getDuration';
import { toMilliseconds } from '@src/domain.operations/manipulate/toMilliseconds';

/**
 * .what = sums multiple iso durations into one
 * .why = enables duration arithmetic for total elapsed time
 */
export function sumDurations(durations: IsoDuration[]): IsoDurationShape;
export function sumDurations(
  durations: IsoDuration[],
  options: { as: keyof IsoDurationShape },
): IsoDurationShape;
export function sumDurations(...durations: IsoDuration[]): IsoDurationShape;
export function sumDurations(
  ...args: IsoDuration[] | [IsoDuration[]] | [IsoDuration[], { as: keyof IsoDurationShape }]
): IsoDurationShape {
  // detect if first arg is array or spread
  const isArrayInput = args.length >= 1 && Array.isArray(args[0]);

  // extract durations and options
  const durations: IsoDuration[] = isArrayInput
    ? (args[0] as IsoDuration[])
    : (args as IsoDuration[]);
  const options = isArrayInput && args.length === 2
    ? (args[1] as { as: keyof IsoDurationShape })
    : undefined;

  // sum all durations via milliseconds
  const totalMilliseconds = durations.reduce(
    (total, duration) => total + toMilliseconds(duration),
    0,
  );

  // return as duration shape
  return getDuration({ of: { milliseconds: totalMilliseconds }, as: options?.as });
}
```

---

## no daos required

this is a pure computation operation — no persistence layer involved

---

## summary

| aspect | answer |
|--------|--------|
| new domain objects | none — reuse current `IsoDuration`, `IsoDurationShape`, `IsoDurationWords` |
| new operations | `sumDurations` in `domain.operations/manipulate/` |
| new daos | none |
| dependencies | `toMilliseconds`, `getDuration` |
| pattern | pure computation leaf operation |
